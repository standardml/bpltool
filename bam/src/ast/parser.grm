exception ShouldntHappen

datatype term =
	 Nil
       | Hole of int
       | Prefix of string * term
       | Par of term list
       | Var of string

type rule = term * term

datatype declaration =
	 RuleDec of string * rule
       | VarDec  of string * term
       | AgentDec of string option * term

fun mkCtrl C = C

fun mkHole i = Hole i

fun mkPar [p] = p
  | mkPar ps  = Par ps


val emptyMap = Util.StringMap.empty
fun lookup map v = case Util.StringMap.lookup map v of
		       SOME t => t
		     | NONE => raise Fail("unbound variable: " ^ v)
fun insert map v t = case Util.StringMap.lookup map v of
			 SOME t => raise Fail("redeclaration of variable: " ^ v)
                       | NONE => Util.StringMap.add(v,t,map)

fun mkTerm map t =
    case t of
	Nil => Term.Nil
      | Hole i => Term.Hole i
      | Prefix(C, t) => Term.Prefix((C,()), mkTerm map t)
      | Par ts => List.foldr (fn (t,a) => Term.Par(mkTerm map t,a)) Term.Nil ts
      | Var v => lookup map v

fun mkRule map (RuleDec (_,(t1, t2))) = Rule.rule (mkTerm map t1, mkTerm map t2)
  | mkRule map _ = raise ShouldntHappen

fun mkAgent map (AgentDec(_, t)) = mkTerm map t
  | mkAgent map _ = raise ShouldntHappen

fun bind (VarDec(s,t), map) = insert map s (mkTerm map t)
  | bind _ = raise ShouldntHappen

fun mkProg declarations =
    let open List
	val (agents, nonagents) = 
	    partition (fn (AgentDec _) => true | _ => false) declarations
	val (rules, vars) =
	    partition (fn (RuleDec _) => true | _ => false) nonagents

	val agent = case agents of [agent] => agent
			         | _ => raise Fail("only one agent can be declared")
	val map = List.foldl bind emptyMap vars
    in  (List.map (mkRule map) rules, mkAgent map agent)
    end

%%


  %header (functor ParserLrValsFun(structure Token: TOKEN))


  %term  
         ONE | BAR | PERIOD | LPAREN | RPAREN
      |  EQ  | ARROW | SEMI
      |  CTRL of string
      |  HOLE of int
      |  VAR of string

      |  RULE | VAL | AGENT

      |  EOF


  %keyword
         RULE VAL AGENT

  %nonterm
         Term of term
      |  TermParList of term list
      |  AtTerm of term
      |  Program of unit Rule.t list * unit Term.t (* everything has been resolved when we return *)
      |  Declaration of declaration
      |  Declarations of declaration list
      |  VarOpt of string option
      |  SemiOpt

  %start Program

  %nodefault
  %name Parser
  %eop EOF
  %noshift EOF
  %verbose
  %pos int

  %left BAR

%%

Program : Declarations                       ( mkProg Declarations )

Declarations :
          Declaration                        ( [Declaration] )
        | Declaration SemiOpt Declarations   ( Declaration :: Declarations )

Declaration:
          RULE VAR EQ Term ARROW Term        ( RuleDec(VAR, (Term1,Term2)) )
        | VAL VAR EQ Term                    ( VarDec(VAR, Term) )
        | AGENT VarOpt EQ Term               ( AgentDec(VarOpt, Term) )

VarOpt:
                                             ( NONE )
        | VAR                                ( SOME VAR )


Term:     TermParList                        ( mkPar TermParList )

TermParList:
          AtTerm                             ( [AtTerm] )
        | AtTerm BAR TermParList             ( AtTerm :: TermParList )

AtTerm:
	  ONE                                ( Nil )
        | CTRL                               ( Prefix(mkCtrl CTRL, Nil) )
        | CTRL PERIOD AtTerm                 ( Prefix(mkCtrl CTRL, AtTerm) )
	| HOLE                               ( mkHole HOLE )
	| LPAREN Term RPAREN                 ( Term )
	| VAR                                ( Var VAR )

SemiOpt:
                                             ( )
        | SEMI                               ( )
