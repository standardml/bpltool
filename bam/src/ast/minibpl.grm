(* Copyright (c) 2007  Henning Niss, IT University of Copenhagen
 *
 * BAM is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * BAM is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with BAM; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
 * USA
 *)

exception ShouldntHappen

datatype term =
	 Nil
       | Hole of int
       | Prefix of string * term
       | Par of term list
       | Var of string

type rule = term * term

datatype declaration =
	 RuleDec of string * rule
       | VarDec  of string * term
       | AgentDec of string option * term

fun mkCtrl C = C

fun mkHole i = Hole i

fun mkPar [p] = p
  | mkPar ps  = Par ps


val emptyMap = Util.StringMap.empty
fun lookup map v = case Util.StringMap.lookup map v of
		       SOME t => t
		     | NONE => raise Fail("unbound variable: " ^ v)
fun insert map v t = case Util.StringMap.lookup map v of
			 SOME t => raise Fail("redeclaration of variable: " ^ v)
                       | NONE => Util.StringMap.add(v,t,map)

fun mkTerm map t =
    case t of
	Nil => Term.Nil
      | Hole i => Term.Hole i
      | Prefix(C, t) => Term.Prefix(Control.ctrl (C,(),Control.ACTIVE), mkTerm map t)
      | Par ts => Term.ParList(List.map (mkTerm map) ts)
      | Var v => lookup map v

fun mkRule map (RuleDec (_,(t1, t2))) = Rule.rule (mkTerm map t1, mkTerm map t2)
  | mkRule map _ = raise ShouldntHappen

fun mkAgent map (AgentDec(_, t)) = mkTerm map t
  | mkAgent map _ = raise ShouldntHappen

fun bind (VarDec(s,t), map) = insert map s (mkTerm map t)
  | bind _ = raise ShouldntHappen

fun mkProg declarations =
    let open List
	val (agents, nonagents) = 
	    partition (fn (AgentDec _) => true | _ => false) declarations
	val (rules, vars) =
	    partition (fn (RuleDec _) => true | _ => false) nonagents

	val agent = case agents of [agent] => agent
			         | _ => raise Fail("only one agent can be declared")
	val map = List.foldl bind emptyMap vars
    in  (List.map (mkRule map) rules, mkAgent map agent)
    end

%%


  %header (functor MiniBPLLrValsFun(structure Token: TOKEN))


  %term  
         ONE | BAR | PERIOD | LPAREN | RPAREN
      |  EQ  | ARROW | COLON | SEMI
      |  CTRL of string
      |  HOLE of int
      |  VAR of string

      |  RULE | VAL | AGENT | SIGNATURE | END
      |  ACTIVE | PASSIVE | ATOMIC | NEW

      |  EOF


  %keyword
         RULE VAL AGENT SIGNATURE END ACTIVE PASSIVE ATOMIC NEW

  %nonterm
         Term of term
      |  TermParList of term list
      |  AtTerm of term
      |  Program of unit Rule.t list * unit Term.t (* everything has been resolved when we return *)
      |  Declaration of declaration
      |  Declarations of declaration list
      |  Activity of Control.activity
      |  SigDef of string * Control.activity
      |  SigDefs of (string * Control.activity) list
      |  Signature of (string * Control.activity) list
      |  VarOpt of string option
      |  SemiOpt

  %start Program

  %nodefault
  %name MiniBPL
  %eop EOF
  %noshift EOF
  %verbose
  %pos int

  %left BAR

%%

Program : Signature Declarations             ( mkProg Declarations )

Signature :
	  SIGNATURE VarOpt EQ SigDefs END    ( SigDefs )

SigDefs : 
          SigDef                             ( [SigDef] )
        | SigDef SemiOpt SigDefs             ( SigDef :: SigDefs )

SigDef :
          CTRL COLON Activity                ( (CTRL, Activity) )

Activity :
          ACTIVE                             ( Control.ACTIVE )
        | PASSIVE                            ( Control.PASSIVE )
        | ATOMIC                             ( Control.PASSIVE )

Declarations :
          Declaration                        ( [Declaration] )
        | Declaration SemiOpt Declarations   ( Declaration :: Declarations )

Declaration:
          RULE VAR EQ Term ARROW Term        ( RuleDec(VAR, (Term1,Term2)) )
        | VAL VAR EQ Term                    ( VarDec(VAR, Term) )
        | AGENT VarOpt EQ Term               ( AgentDec(VarOpt, Term) )

VarOpt:
                                             ( NONE )
        | VAR                                ( SOME VAR )


Term:     TermParList                        ( mkPar TermParList )

TermParList:
          AtTerm                             ( [AtTerm] )
        | AtTerm BAR TermParList             ( AtTerm :: TermParList )

AtTerm:
	  ONE                                ( Nil )
        | CTRL                               ( Prefix(mkCtrl CTRL, Nil) )
        | CTRL PERIOD AtTerm                 ( Prefix(mkCtrl CTRL, AtTerm) )
(*
        | NEW VAR PERIOD AtTerm              ( Restriction(VAR, AtTerm) )
*)
	| HOLE                               ( mkHole HOLE )
	| LPAREN Term RPAREN                 ( Term )
	| VAR                                ( Var VAR )

SemiOpt:
                                             ( )
        | SEMI                               ( )
